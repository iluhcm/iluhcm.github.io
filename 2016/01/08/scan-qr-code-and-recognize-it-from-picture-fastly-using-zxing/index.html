<!doctype html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="2yx0JNDw3DWn3FVwl0XV9ba4wAjjbvZ3viXpvjGwBa8" />













  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android,zxing,QR Code,Optimization Strategy,Camera," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="二维码介绍Android中用于二维码相关的库比较少，并且大多数已经不再维护（具体可见https://android-arsenal.com/tag/81）。其中最常用的是zxing和zbar。 zxing项目是谷歌推出的用来识别多种格式条形码的开源项目，项目地址为https://github.com/zxing/zxing，zxing有多个人在维护，覆盖主流编程语言，也是目前还在维护的较受欢迎的二">
<meta name="keywords" content="Android,zxing,QR Code,Optimization Strategy,Camera">
<meta property="og:type" content="article">
<meta property="og:title" content="zxing扫描二维码和识别图片二维码及其优化策略">
<meta property="og:url" content="http://iluhcm.com/2016/01/08/scan-qr-code-and-recognize-it-from-picture-fastly-using-zxing/index.html">
<meta property="og:site_name" content="Xing&#39;s Blog">
<meta property="og:description" content="二维码介绍Android中用于二维码相关的库比较少，并且大多数已经不再维护（具体可见https://android-arsenal.com/tag/81）。其中最常用的是zxing和zbar。 zxing项目是谷歌推出的用来识别多种格式条形码的开源项目，项目地址为https://github.com/zxing/zxing，zxing有多个人在维护，覆盖主流编程语言，也是目前还在维护的较受欢迎的二">
<meta property="og:updated_time" content="2017-03-27T09:16:08.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zxing扫描二维码和识别图片二维码及其优化策略">
<meta name="twitter:description" content="二维码介绍Android中用于二维码相关的库比较少，并且大多数已经不再维护（具体可见https://android-arsenal.com/tag/81）。其中最常用的是zxing和zbar。 zxing项目是谷歌推出的用来识别多种格式条形码的开源项目，项目地址为https://github.com/zxing/zxing，zxing有多个人在维护，覆盖主流编程语言，也是目前还在维护的较受欢迎的二">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://iluhcm.com/2016/01/08/scan-qr-code-and-recognize-it-from-picture-fastly-using-zxing/"/>





  <title>zxing扫描二维码和识别图片二维码及其优化策略 | Xing's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?03e8bdd436b4561c8e760c9459ee8003";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xing's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">To be a better man.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://iluhcm.com/2016/01/08/scan-qr-code-and-recognize-it-from-picture-fastly-using-zxing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xing Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">zxing扫描二维码和识别图片二维码及其优化策略</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-01-08T22:16:25+08:00">
                2016-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/01/08/scan-qr-code-and-recognize-it-from-picture-fastly-using-zxing/" class="leancloud_visitors" data-flag-title="zxing扫描二维码和识别图片二维码及其优化策略">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="二维码介绍"><a href="#二维码介绍" class="headerlink" title="二维码介绍"></a>二维码介绍</h1><p>Android中用于二维码相关的库比较少，并且大多数已经不再维护（具体可见<a href="https://android-arsenal.com/tag/81" target="_blank" rel="external">https://android-arsenal.com/tag/81</a>）。其中最常用的是zxing和zbar。</p>
<p>zxing项目是谷歌推出的用来识别多种格式条形码的开源项目，项目地址为<a href="https://github.com/zxing/zxing" target="_blank" rel="external">https://github.com/zxing/zxing</a>，zxing有多个人在维护，覆盖主流编程语言，也是目前还在维护的较受欢迎的二维码扫描开源项目之一。zbar则是主要用C来写的，速度极快，推出了iPhone的SDK和Android的相关调用方法（JNI），但这个项目已经有几年不维护了，目前并没有维护下去的意思，见<a href="https://github.com/ZBar/ZBar" target="_blank" rel="external">https://github.com/ZBar/ZBar</a>。</p>
<p>zxing的项目很庞大，主要的核心代码在<code>core</code>文件夹里面，也可以单独下载由这个文件夹打包而成的<code>jar</code>包，具体地址在<a href="http://mvnrepository.com/artifact/com.google.zxing/core" target="_blank" rel="external">http://mvnrepository.com/artifact/com.google.zxing/core</a>，直接下载jar包也省去了通过<code>maven</code>编译的麻烦，如果喜欢折腾的，可以从<a href="https://github.com/zxing/zxing/wiki/Getting-Started-Developing" target="_blank" rel="external">https://github.com/zxing/zxing/wiki/Getting-Started-Developing</a>获取帮助文档。</p>
<p>本文不分析二维码的生成原理和解析原理，感兴趣的可以参考陈皓的博客<a href="http://coolshell.cn/articles/10590.html" target="_blank" rel="external">二维码的生成细节和原理</a>。</p>
<h1 id="zxing基本使用"><a href="#zxing基本使用" class="headerlink" title="zxing基本使用"></a>zxing基本使用</h1><p>官方提供了zxing在Android机子上的使用例子，<a href="https://github.com/zxing/zxing/tree/master/android" target="_blank" rel="external">https://github.com/zxing/zxing/tree/master/android</a>，作为官方的例子，zxing-android考虑了各种各样的情况，包括多种解析格式、解析得到的结果分类、长时间无活动自动销毁机制等。有时候我们需要根据自己的情况定制使用需求，因此会精简官方给的例子。在项目中，我们仅仅用来实现扫描二维码和识别图片二维码两个功能。为了实现高精度的二维码识别，在zxing原有项目的基础上，本文做了大量改进，使得二维码识别的效率有所提升。先来看看工程的项目结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── QrCodeActivity.java</div><div class="line">├── camera</div><div class="line">│   ├── AutoFocusCallback.java</div><div class="line">│   ├── CameraConfigurationManager.java</div><div class="line">│   ├── CameraManager.java</div><div class="line">│   └── PreviewCallback.java</div><div class="line">├── decode</div><div class="line">│   ├── CaptureActivityHandler.java</div><div class="line">│   ├── DecodeHandler.java</div><div class="line">│   ├── DecodeImageCallback.java</div><div class="line">│   ├── DecodeImageThread.java</div><div class="line">│   ├── DecodeManager.java</div><div class="line">│   ├── DecodeThread.java</div><div class="line">│   ├── FinishListener.java</div><div class="line">│   └── InactivityTimer.java</div><div class="line">├── utils</div><div class="line">│   ├── QrUtils.java</div><div class="line">│   └── ScreenUtils.java</div><div class="line">└── view</div><div class="line">    └── QrCodeFinderView.java</div></pre></td></tr></table></figure>
<p>源码比较简单，这里不做过多地讲解，大部分方法都有注释。主要分为几大块，</p>
<ul>
<li>camera</li>
</ul>
<p>主要实现相机的配置和管理，相机自动聚焦功能，以及相机成像回调（通过<code>byte[]</code>数组返回实际的数据）。</p>
<ul>
<li>decode</li>
</ul>
<p>图片解析相关类。通过相机扫描二维码和解析图片使用两套逻辑。前者对实时性要求比较高，后者对解析结果要求较高，因此采用不同的配置。相机扫描主要在<code>DecodeHandler</code>里通过串行的方式解析，图片识别主要通过线程<code>DecodeImageThread</code>异步调用返回回调的结果。<code>FinishListener</code>和<code>InactivityTimer</code>用来控制长时间无活动时自动销毁创建的Activity，避免耗电。</p>
<ul>
<li>utils</li>
</ul>
<p>图片二维码解析工具类，以及获取屏幕宽高的工具类。</p>
<ul>
<li>view</li>
</ul>
<p>这个包里只有一个类<code>QrCodeFinderView</code>，官方原本是使用这个类绘制扫描区域框，并且必须在扫描区域里才能识别二维码。我把这个类稍作修改，仅仅用来展示扫描区域，实际在相机扫描二维码的时候，只要在<code>SurfaceView</code>区域范围内，结果都是有效的。</p>
<ul>
<li>QrCodeActivity</li>
</ul>
<p>启动类，包含相机扫描二维码以及选择图片入口。</p>
<h1 id="zxing源码存在的问题及解决方案"><a href="#zxing源码存在的问题及解决方案" class="headerlink" title="zxing源码存在的问题及解决方案"></a>zxing源码存在的问题及解决方案</h1><p>zxing项目源码实现了基本的二维码扫描及图片识别程序，但下载过源码并直接运行的童鞋都知道，例子存在很多的问题，包括基本的识别精准度不高、扫描区域小、部分手机存在预览图形拉伸、默认横向扫描、还有自定义扫描界面困难等问题。</p>
<h2 id="图形拉伸问题"><a href="#图形拉伸问题" class="headerlink" title="图形拉伸问题"></a>图形拉伸问题</h2><p>先来了解一下为什么会产生图形拉伸。Android手机的屏幕分辨率可以说不胜枚举，不同型号的宽高比可能是不一样的，例如Nexus 5x、小米4的分辨率是1920X1080（当前主流手机的分辨率都是这个级别），Nexus 6p的分辨率达到2560X1440。而每台手机使用的摄像头型号更是千变万化，手机摄像头有一个成像的像素。例如普通的卡片数码相机，常常可以看到类似2304X1728、1600X1200、1027X768、640X480的字样，这些数字相乘得到的结果就代表了这个相机的成像分辨率。手机里内置的摄像头和卡片数码相机的成像原理是一样的，在摄像头预览的时候，最终都会生成连续固定像素的图片，这张图片会被投影到手机的屏幕上。<strong>如果摄像头生成的预览图片宽高比和手机屏幕像素宽高比（准确地说是和相机预览屏幕宽高比）不一样的话，投影的结果肯定就是图片被拉伸。</strong></p>
<p>原项目其实有解决图形拉伸的问题，并且用了很细致的办法，考虑了各种机型的兼容性问题首先来看zxing是怎么解决图形拉伸问题的。在<code>CameraConfigurationManager</code>类里，初始化相机配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Reads, one time, values from the camera that are needed by the app.</div><div class="line"> */</div><div class="line">void initFromCameraParameters(OpenCamera camera) &#123;</div><div class="line">    Camera.Parameters parameters = camera.getCamera().getParameters();</div><div class="line">    WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</div><div class="line">    Display display = manager.getDefaultDisplay();</div><div class="line"></div><div class="line">    // 判断屏幕方向，是否有需要从自然角度旋转到显示器角度</div><div class="line">    int displayRotation = display.getRotation();</div><div class="line">    int cwRotationFromNaturalToDisplay;</div><div class="line">    switch (displayRotation) &#123;</div><div class="line">        case Surface.ROTATION_0:</div><div class="line">            cwRotationFromNaturalToDisplay = 0;</div><div class="line">            break;</div><div class="line">        case Surface.ROTATION_90:</div><div class="line">            cwRotationFromNaturalToDisplay = 90;</div><div class="line">            break;</div><div class="line">        case Surface.ROTATION_180:</div><div class="line">            cwRotationFromNaturalToDisplay = 180;</div><div class="line">            break;</div><div class="line">        case Surface.ROTATION_270:</div><div class="line">            cwRotationFromNaturalToDisplay = 270;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            // Have seen this return incorrect values like -90</div><div class="line">            if (displayRotation % 90 == 0) &#123;</div><div class="line">                cwRotationFromNaturalToDisplay = (360 + displayRotation) % 360;</div><div class="line">            &#125; else &#123;</div><div class="line">                throw new IllegalArgumentException(&quot;Bad rotation: &quot; + displayRotation);</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    Log.i(TAG, &quot;Display at: &quot; + cwRotationFromNaturalToDisplay);</div><div class="line"></div><div class="line">    //判断相机的方向，根据前后摄像机判断是否有需要旋转</div><div class="line">    int cwRotationFromNaturalToCamera = camera.getOrientation();</div><div class="line">    Log.i(TAG, &quot;Camera at: &quot; + cwRotationFromNaturalToCamera);</div><div class="line"></div><div class="line">    // Still not 100% sure about this. But acts like we need to flip this:</div><div class="line">    if (camera.getFacing() == CameraFacing.FRONT) &#123;</div><div class="line">        cwRotationFromNaturalToCamera = (360 - cwRotationFromNaturalToCamera) % 360;</div><div class="line">        Log.i(TAG, &quot;Front camera overriden to: &quot; + cwRotationFromNaturalToCamera);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //根据屏幕方向和相机方向判断是否有需要进行旋转</div><div class="line">    cwRotationFromDisplayToCamera = (360 + cwRotationFromNaturalToCamera - cwRotationFromNaturalToDisplay) % 360;</div><div class="line">    Log.i(TAG, &quot;Final display orientation: &quot; + cwRotationFromDisplayToCamera);</div><div class="line">    if (camera.getFacing() == CameraFacing.FRONT) &#123;</div><div class="line">        Log.i(TAG, &quot;Compensating rotation for front camera&quot;);</div><div class="line">        cwNeededRotation = (360 - cwRotationFromDisplayToCamera) % 360;</div><div class="line">    &#125; else &#123;</div><div class="line">        cwNeededRotation = cwRotationFromDisplayToCamera;</div><div class="line">    &#125;</div><div class="line">    Log.i(TAG, &quot;Clockwise rotation from display to camera: &quot; + cwNeededRotation);</div><div class="line"></div><div class="line">    Point theScreenResolution = new Point();</div><div class="line">    display.getSize(theScreenResolution);</div><div class="line">    screenResolution = theScreenResolution;</div><div class="line">    Log.i(TAG, &quot;Screen resolution in current orientation: &quot; + screenResolution);</div><div class="line">    // 寻找最佳的预览宽高值</div><div class="line">    cameraResolution = CameraConfigurationUtils.findBestPreviewSizeValue(parameters, screenResolution);</div><div class="line">    Log.i(TAG, &quot;Camera resolution: &quot; + cameraResolution);</div><div class="line">    bestPreviewSize = CameraConfigurationUtils.findBestPreviewSizeValue(parameters, screenResolution);</div><div class="line">    Log.i(TAG, &quot;Best available preview size: &quot; + bestPreviewSize);</div><div class="line"></div><div class="line">    boolean isScreenPortrait = screenResolution.x &lt; screenResolution.y;</div><div class="line">    boolean isPreviewSizePortrait = bestPreviewSize.x &lt; bestPreviewSize.y;</div><div class="line"></div><div class="line">    if (isScreenPortrait == isPreviewSizePortrait) &#123;</div><div class="line">        previewSizeOnScreen = bestPreviewSize;</div><div class="line">    &#125; else &#123;</div><div class="line">        previewSizeOnScreen = new Point(bestPreviewSize.y, bestPreviewSize.x);</div><div class="line">    &#125;</div><div class="line">    Log.i(TAG, &quot;Preview size on screen: &quot; + previewSizeOnScreen);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来看一下<code>CameraConfigurationUtils.findBestPreviewSizeValue(Camera.Parameters,Point)</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">public static Point findBestPreviewSizeValue(Camera.Parameters parameters, Point screenResolution) &#123;</div><div class="line"></div><div class="line">    // 获取当前手机支持的屏幕预览尺寸</div><div class="line">    List&lt;Camera.Size&gt; rawSupportedSizes = parameters.getSupportedPreviewSizes();</div><div class="line">    if (rawSupportedSizes == null) &#123;</div><div class="line">        Log.w(TAG, &quot;Device returned no supported preview sizes; using default&quot;);</div><div class="line">        Camera.Size defaultSize = parameters.getPreviewSize();</div><div class="line">        if (defaultSize == null) &#123;</div><div class="line">            throw new IllegalStateException(&quot;Parameters contained no preview size!&quot;);</div><div class="line">        &#125;</div><div class="line">        return new Point(defaultSize.width, defaultSize.height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 对这些尺寸根据像素值（即宽乘高的值）进行重小到大排序</div><div class="line">    List&lt;Camera.Size&gt; supportedPreviewSizes = new ArrayList&lt;&gt;(rawSupportedSizes);</div><div class="line">    Collections.sort(supportedPreviewSizes, new Comparator&lt;Camera.Size&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public int compare(Camera.Size a, Camera.Size b) &#123;</div><div class="line">            int aPixels = a.height * a.width;</div><div class="line">            int bPixels = b.height * b.width;</div><div class="line">            if (bPixels &lt; aPixels) &#123;</div><div class="line">                return -1;</div><div class="line">            &#125;</div><div class="line">            if (bPixels &gt; aPixels) &#123;</div><div class="line">                return 1;</div><div class="line">            &#125;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    double screenAspectRatio = (double) screenResolution.x / (double) screenResolution.y;</div><div class="line"></div><div class="line">    Iterator&lt;Camera.Size&gt; it = supportedPreviewSizes.iterator();</div><div class="line">    while (it.hasNext()) &#123;</div><div class="line">        Camera.Size supportedPreviewSize = it.next();</div><div class="line">        int realWidth = supportedPreviewSize.width;</div><div class="line">        int realHeight = supportedPreviewSize.height;</div><div class="line">        // 首先把不符合最小预览像素值的尺寸排除</div><div class="line">        if (realWidth * realHeight &lt; MIN_PREVIEW_PIXELS) &#123;</div><div class="line">            it.remove();</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        boolean isCandidatePortrait = realWidth &lt; realHeight;</div><div class="line">        int maybeFlippedWidth = isCandidatePortrait ? realHeight : realWidth;</div><div class="line">        int maybeFlippedHeight = isCandidatePortrait ? realWidth : realHeight;</div><div class="line">        double aspectRatio = (double) maybeFlippedWidth / (double) maybeFlippedHeight;</div><div class="line">        double distortion = Math.abs(aspectRatio - screenAspectRatio);</div><div class="line">        // 根据宽高比判断是否满足最大误差要求（默认最大值为0.15，即宽高比默认不能超过给定比例的15%）</div><div class="line">        if (distortion &gt; MAX_ASPECT_DISTORTION) &#123;</div><div class="line">            it.remove();</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (maybeFlippedWidth == screenResolution.x &amp;&amp; maybeFlippedHeight == screenResolution.y) &#123;</div><div class="line">            Point exactPoint = new Point(realWidth, realHeight);</div><div class="line">            Log.i(TAG, &quot;Found preview size exactly matching screen size: &quot; + exactPoint);</div><div class="line">            return exactPoint;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果没有精确匹配到合适的尺寸，则使用最大的尺寸，这样设置便是预览图像可能产生拉伸的根本原因。</div><div class="line">    if (!supportedPreviewSizes.isEmpty()) &#123;</div><div class="line">        Camera.Size largestPreview = supportedPreviewSizes.get(0);</div><div class="line">        Point largestSize = new Point(largestPreview.width, largestPreview.height);</div><div class="line">        Log.i(TAG, &quot;Using largest suitable preview size: &quot; + largestSize);</div><div class="line">        return largestSize;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果没有找到合适的尺寸，就返回默认设定的尺寸</div><div class="line">    Camera.Size defaultPreview = parameters.getPreviewSize();</div><div class="line">    if (defaultPreview == null) &#123;</div><div class="line">        throw new IllegalStateException(&quot;Parameters contained no preview size!&quot;);</div><div class="line">    &#125;</div><div class="line">    Point defaultSize = new Point(defaultPreview.width, defaultPreview.height);</div><div class="line">    Log.i(TAG, &quot;No suitable preview sizes, using default: &quot; + defaultSize);</div><div class="line">    return defaultSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从注释中已经可以清楚地看到zxing项目在寻找最佳尺寸值的方法：</p>
<ul>
<li>首先，查找手机支持的预览尺寸集合，如果集合为空，就返回默认的尺寸；否则，对尺寸集合根据尺寸的像素从小到大进行排序；</li>
<li>其次，移除不满足最小像素要求的所有尺寸；</li>
<li>在者，在剩余的尺寸集合中，剔除预览宽高比与屏幕分辨率宽高比之差的绝对值大于0.15的所有尺寸；</li>
<li>最后，寻找能够精确的与屏幕宽高匹配上的预览尺寸，如果存在则返回该宽高比；如果不存在，则使用尺寸集合中最大的那个尺寸。如果说尺寸集合已经在前面的过滤中被全部排除，则返回相机默认的尺寸值。</li>
</ul>
<p>zxing寻找最佳预览尺寸的前三步剔除了部分不符合要求的尺寸集合，在最后一步，如果没有精确匹配到与屏幕分辨率一样的尺寸，则使用最大的尺寸。问题的关键就在这里，<strong>最大的尺寸宽高比与屏幕宽高比相差可能很大（根据剔除规则，差距可能超过15%）。</strong></p>
<p>根据这个规则，我修改了寻找最佳尺寸的源码，<strong>将算法的核心从最大的尺寸改为比例最接近的尺寸</strong>，这样便能够最原始地接近屏幕分辨率的宽高比，即拉伸几乎看不出来。首先定义一个比较器，用来对支持的预览尺寸集合进行排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 预览尺寸与给定的宽高尺寸比较器。首先比较宽高的比例，在宽高比相同的情况下，根据宽和高的最小差进行比较。</div><div class="line"> */</div><div class="line">private static class SizeComparator implements Comparator&lt;Camera.Size&gt; &#123;</div><div class="line"></div><div class="line">    private final int width;</div><div class="line">    private final int height;</div><div class="line">    private final float ratio;</div><div class="line"></div><div class="line">    SizeComparator(int width, int height) &#123;</div><div class="line">        if (width &lt; height) &#123;</div><div class="line">            this.width = height;</div><div class="line">            this.height = width;</div><div class="line">        &#125; else &#123;</div><div class="line">            this.width = width;</div><div class="line">            this.height = height;</div><div class="line">        &#125;</div><div class="line">        this.ratio = (float) this.height / this.width;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int compare(Camera.Size size1, Camera.Size size2) &#123;</div><div class="line">        int width1 = size1.width;</div><div class="line">        int height1 = size1.height;</div><div class="line">        int width2 = size2.width;</div><div class="line">        int height2 = size2.height;</div><div class="line"></div><div class="line">        float ratio1 = Math.abs((float) height1 / width1 - ratio);</div><div class="line">        float ratio2 = Math.abs((float) height2 / width2 - ratio);</div><div class="line">        int result = Float.compare(ratio1, ratio2);</div><div class="line">        if (result != 0) &#123;</div><div class="line">            return result;</div><div class="line">        &#125; else &#123;</div><div class="line">            int minGap1 = Math.abs(width - width1) + Math.abs(height - height1);</div><div class="line">            int minGap2 = Math.abs(width - width2) + Math.abs(height - height2);</div><div class="line">            return minGap1 - minGap2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目的就是根据宽高比来排序，然后调用方法取最小的那个值就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 通过对比得到与宽高比最接近的尺寸（如果有相同尺寸，优先选择）</div><div class="line"> *</div><div class="line"> * @param surfaceWidth 需要被进行对比的原宽</div><div class="line"> * @param surfaceHeight 需要被进行对比的原高</div><div class="line"> * @param preSizeList 需要对比的预览尺寸列表</div><div class="line"> * @return 得到与原宽高比例最接近的尺寸</div><div class="line"> */</div><div class="line">protected Camera.Size findCloselySize(int surfaceWidth, int surfaceHeight, List&lt;Camera.Size&gt; preSizeList) &#123;</div><div class="line">    Collections.sort(preSizeList, new SizeComparator(surfaceWidth, surfaceHeight));</div><div class="line">    return preSizeList.get(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后在初始化相机尺寸的时候分别对预览尺寸值和图片尺寸值都设定为比例最接近屏幕尺寸的尺寸值就可以了。本文使用的方法精简了zxing项目的步骤，实际上项目中使用的前三步滤除还是很有必要的，这里为了简短略去了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void initFromCameraParameters(Camera camera) &#123;</div><div class="line">    Camera.Parameters parameters = camera.getParameters();</div><div class="line">    mCameraResolution = findCloselySize(ScreenUtils.getScreenWidth(mContext), ScreenUtils.getScreenHeight(mContext),</div><div class="line">        parameters.getSupportedPreviewSizes());</div><div class="line">    Log.e(TAG, &quot;Setting preview size: &quot; + mCameraResolution.width + &quot;-&quot; + mCameraResolution.height);</div><div class="line">    mPictureResolution = findCloselySize(ScreenUtils.getScreenWidth(mContext),</div><div class="line">        ScreenUtils.getScreenHeight(mContext), parameters.getSupportedPictureSizes());</div><div class="line">    Log.e(TAG, &quot;Setting picture size: &quot; + mPictureResolution.width + &quot;-&quot; + mPictureResolution.height);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="扫描精度问题"><a href="#扫描精度问题" class="headerlink" title="扫描精度问题"></a>扫描精度问题</h2><p>使用过zxing自带的二维码扫描程序来识别二维码的童鞋应该知道，zxing二维码的扫描程序很慢，而且有可能扫不出来。zxing在配置相机参数和二维码扫描程序参数的时候，配置都比较保守，兼顾了低端手机，并且兼顾了多种条形码的识别。如果说仅仅是拿zxing项目来扫描和识别二维码的话，完全可以对项目中的一些配置做精简，并针对二维码的识别做优化。</p>
<h3 id="PlanarYUVLuminanceSource"><a href="#PlanarYUVLuminanceSource" class="headerlink" title="PlanarYUVLuminanceSource"></a>PlanarYUVLuminanceSource</h3><p>官方的解码程序主要是下边这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private void decode(byte[] data, int width, int height) &#123;</div><div class="line">    long start = System.currentTimeMillis();</div><div class="line">    Result rawResult = null;</div><div class="line">    // 构造基于平面的YUV亮度源，即包含二维码区域的数据源</div><div class="line">    PlanarYUVLuminanceSource source = activity.getCameraManager().buildLuminanceSource(data, width, height);</div><div class="line">    if (source != null) &#123;</div><div class="line">        // 构造二值图像比特流，使用HybridBinarizer算法解析数据源</div><div class="line">        BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));</div><div class="line">        try &#123;</div><div class="line">            // 采用MultiFormatReader解析图像，可以解析多种数据格式</div><div class="line">            rawResult = multiFormatReader.decodeWithState(bitmap);</div><div class="line">        &#125; catch (ReaderException re) &#123;</div><div class="line">            // continue</div><div class="line">        &#125; finally &#123;</div><div class="line">            multiFormatReader.reset();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	···</div><div class="line">	// Hanlder处理解析失败或成功的结果</div><div class="line">	···</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来看看YUV亮度源是怎么构造的，在<code>CameraManager</code>里，首先获取预览图像的聚焦框矩形<code>getFramingRect()</code>，这个聚焦框的矩形大小是根据屏幕的宽高值来做计算的，官方定义了最小和最大的聚焦框大小，分别是<code>240*240</code>和<code>1200*675</code>，即最多的聚焦框大小为屏幕宽高的5/8。获取屏幕的聚焦框大小后，还需要做从屏幕分辨率到相机分辨率的转换才能得到预览聚焦框的大小，这个转换在<code>getFramingRectInPreview()</code>里完成。这样便完成了亮度源的构造。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">private static final int MIN_FRAME_WIDTH = 240;</div><div class="line">private static final int MIN_FRAME_HEIGHT = 240;</div><div class="line">private static final int MAX_FRAME_WIDTH = 1200; // = 5/8 * 1920</div><div class="line">private static final int MAX_FRAME_HEIGHT = 675; // = 5/8 * 1080</div><div class="line"></div><div class="line">/**</div><div class="line"> * A factory method to build the appropriate LuminanceSource object based on the format of the preview buffers, as</div><div class="line"> * described by Camera.Parameters.</div><div class="line"> *</div><div class="line"> * @param data A preview frame.</div><div class="line"> * @param width The width of the image.</div><div class="line"> * @param height The height of the image.</div><div class="line"> * @return A PlanarYUVLuminanceSource instance.</div><div class="line"> */</div><div class="line">public PlanarYUVLuminanceSource buildLuminanceSource(byte[] data, int width, int height) &#123;</div><div class="line">    // 取得预览框内的矩形</div><div class="line">    Rect rect = getFramingRectInPreview();</div><div class="line">    if (rect == null) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    // Go ahead and assume it&apos;s YUV rather than die.</div><div class="line">    return new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top, rect.width(), rect.height(),</div><div class="line">        false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Like &#123;@link #getFramingRect&#125; but coordinates are in terms of the preview frame, not UI / screen.</div><div class="line"> *</div><div class="line"> * @return &#123;@link Rect&#125; expressing barcode scan area in terms of the preview size</div><div class="line"> */</div><div class="line">public synchronized Rect getFramingRectInPreview() &#123;</div><div class="line">    if (framingRectInPreview == null) &#123;</div><div class="line">        Rect framingRect = getFramingRect();</div><div class="line">        if (framingRect == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        // 获取相机分辨率和屏幕分辨率</div><div class="line">        Rect rect = new Rect(framingRect);</div><div class="line">        Point cameraResolution = configManager.getCameraResolution();</div><div class="line">        Point screenResolution = configManager.getScreenResolution();</div><div class="line">        if (cameraResolution == null || screenResolution == null) &#123;</div><div class="line">            // Called early, before init even finished</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        // 根据相机分辨率和屏幕分辨率的比例对屏幕中央聚焦框进行调整</div><div class="line">        rect.left = rect.left * cameraResolution.x / screenResolution.x;</div><div class="line">        rect.right = rect.right * cameraResolution.x / screenResolution.x;</div><div class="line">        rect.top = rect.top * cameraResolution.y / screenResolution.y;</div><div class="line">        rect.bottom = rect.bottom * cameraResolution.y / screenResolution.y;</div><div class="line">        framingRectInPreview = rect;</div><div class="line">    &#125;</div><div class="line">    return framingRectInPreview;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Calculates the framing rect which the UI should draw to show the user where to place the barcode. This target</div><div class="line"> * helps with alignment as well as forces the user to hold the device far enough away to ensure the image will be in</div><div class="line"> * focus.</div><div class="line"> *</div><div class="line"> * @return The rectangle to draw on screen in window coordinates.</div><div class="line"> */</div><div class="line">public synchronized Rect getFramingRect() &#123;</div><div class="line">    if (framingRect == null) &#123;</div><div class="line">        if (camera == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        // 获取屏幕的尺寸像素</div><div class="line">        Point screenResolution = configManager.getScreenResolution();</div><div class="line">        if (screenResolution == null) &#123;</div><div class="line">            // Called early, before init even finished</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        // 根据屏幕的宽高找到最合适的矩形框宽高值</div><div class="line">        int width = findDesiredDimensionInRange(screenResolution.x, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);</div><div class="line">        int height = findDesiredDimensionInRange(screenResolution.y, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);</div><div class="line"></div><div class="line">        // 取屏幕中间的，宽为width，高为height的矩形框</div><div class="line">        int leftOffset = (screenResolution.x - width) / 2;</div><div class="line">        int topOffset = (screenResolution.y - height) / 2;</div><div class="line">        framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);</div><div class="line">        Log.d(TAG, &quot;Calculated framing rect: &quot; + framingRect);</div><div class="line">    &#125;</div><div class="line">    return framingRect;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static int findDesiredDimensionInRange(int resolution, int hardMin, int hardMax) &#123;</div><div class="line">    int dim = 5 * resolution / 8; // Target 5/8 of each dimension</div><div class="line">    if (dim &lt; hardMin) &#123;</div><div class="line">        return hardMin;</div><div class="line">    &#125;</div><div class="line">    if (dim &gt; hardMax) &#123;</div><div class="line">        return hardMax;</div><div class="line">    &#125;</div><div class="line">    return dim;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码并没有什么问题，也完全符合逻辑。但为什么在扫描的时候这么难扫到二维码呢，原因在于官方为了减少解码的数据，提高解码效率和速度，采用了<strong>裁剪无用区域的方式</strong>。这样会带来一定的问题，整个二维码数据需要完全放到聚焦框里才有可能被识别，并且在<code>buildLuminanceSource(byte[],int,int)</code>这个方法签名中，传入的byte数组便是图像的数据，并没有因为裁剪而使数据量减小，而是采用了取这个数组中的部分数据来达到裁剪的目的。对于目前CPU性能过剩的大多数智能手机来说，这种裁剪显得没有必要。如果把解码数据换成采用全幅图像数据，这样在识别的过程中便不再拘束于聚焦框，也使得二维码数据可以铺满整个屏幕。这样用户在使用程序来扫描二维码时，尽管不完全对准聚焦框，也可以识别出来。这属于一种策略上的让步，给用户造成了错觉，但提高了识别的精度。</p>
<p>解决办法很简单，就是不仅仅使用聚焦框里的图像数据，而是采用全幅图像的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public PlanarYUVLuminanceSource buildLuminanceSource(byte[] data, int width, int height) &#123;</div><div class="line">    // 直接返回整幅图像的数据，而不计算聚焦框大小。</div><div class="line">    return new PlanarYUVLuminanceSource(data, width, height, 0, 0, width, height, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="DecodeHintType"><a href="#DecodeHintType" class="headerlink" title="DecodeHintType"></a>DecodeHintType</h3><p>在使用zxing解析二维码时，允许事先进行相关配置，这个文件通过<code>Map&lt;DecodeHintType, ?&gt;</code>键值对来保存，然后使用方法<code>public void setHints(Map&lt;DecodeHintType,?&gt; hints)</code>来设置到相应的解码器中。DecodeHintType是一个枚举类，其中有几个重要的枚举值，</p>
<ul>
<li>POSSIBLE_FORMATS(List.class)</li>
</ul>
<p>用于列举支持的解析格式，一共有17种，在<code>com.google.zxing.BarcodeFormat</code>里定义。官方默认支持所有的格式。</p>
<ul>
<li>TRY_HARDER(Void.class)</li>
</ul>
<p>是否使用HARDER模式来解析数据，如果启用，则会花费更多的时间去解析二维码，对精度有优化，对速度则没有。</p>
<ul>
<li>CHARACTER_SET(String.class)</li>
</ul>
<p>解析的字符集。这个对解析也比较关键，最好定义需要解析数据对应的字符集。</p>
<p>如果项目仅仅用来解析二维码，完全没必要支持所有的格式，也没有必要使用<code>MultiFormatReader</code>来解析。所以在配置的过程中，我移除了所有与二维码不相关的代码。直接使用<code>QRCodeReader</code>类来解析，字符集采用utf-8，使用Harder模式，并且把可能的解析格式只定义为<code>BarcodeFormat.QR_CODE</code>，这对于直接二维码扫描解析无疑是帮助最大的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private final Map&lt;DecodeHintType, Object&gt; mHints;</div><div class="line">DecodeHandler(QrCodeActivity activity) &#123;</div><div class="line">    this.mActivity = activity;</div><div class="line">    mQrCodeReader = new QRCodeReader();</div><div class="line">    mHints = new Hashtable&lt;&gt;();</div><div class="line">    mHints.put(DecodeHintType.CHARACTER_SET, &quot;utf-8&quot;);</div><div class="line">    mHints.put(DecodeHintType.TRY_HARDER, Boolean.TRUE);</div><div class="line">    mHints.put(DecodeHintType.POSSIBLE_FORMATS, BarcodeFormat.QR_CODE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="二维码图像识别精度探究"><a href="#二维码图像识别精度探究" class="headerlink" title="二维码图像识别精度探究"></a>二维码图像识别精度探究</h1><h2 id="图像-像素编码格式"><a href="#图像-像素编码格式" class="headerlink" title="图像/像素编码格式"></a>图像/像素编码格式</h2><p>Android相机预览的时候支持几种不同的格式，从图像的角度（<a href="http://developer.android.com/intl/zh-cn/reference/android/graphics/ImageFormat.html" target="_blank" rel="external">ImageFormat</a>）来说有NV16、NV21、YUY2、YV12、RGB_565和JPEG，从像素的角度（<a href="http://developer.android.com/intl/zh-cn/reference/android/graphics/PixelFormat.html" target="_blank" rel="external">PixelFormat</a>）来说，有YUV422SP、YUV420SP、YUV422I、YUV420P、RGB565和JPEG，它们之间的对应关系可以从<code>Camera.Parameters.cameraFormatForPixelFormat(int)</code>方法中得到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private String cameraFormatForPixelFormat(int pixel_format) &#123;</div><div class="line">    switch(pixel_format) &#123;</div><div class="line">    case ImageFormat.NV16:      return PIXEL_FORMAT_YUV422SP;</div><div class="line">    case ImageFormat.NV21:      return PIXEL_FORMAT_YUV420SP;</div><div class="line">    case ImageFormat.YUY2:      return PIXEL_FORMAT_YUV422I;</div><div class="line">    case ImageFormat.YV12:      return PIXEL_FORMAT_YUV420P;</div><div class="line">    case ImageFormat.RGB_565:   return PIXEL_FORMAT_RGB565;</div><div class="line">    case ImageFormat.JPEG:      return PIXEL_FORMAT_JPEG;</div><div class="line">    default:                    return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目前大部分Android手机摄像头设置的默认格式是<code>yuv420sp</code>，其原理可参考文章<a href="http://www.cnblogs.com/azraelly/archive/2013/01/01/2841269.html" target="_blank" rel="external">《图文详解YUV420数据格式》</a>。编码成YUV的所有像素格式里，yuv420sp占用的空间是最小的。既然如此，zxing当然会考虑到这种情况。因此针对YUV编码的数据，有<code>PlanarYUVLuminanceSource</code>这个类去处理，而针对RGB编码的数据，则使用<code>RGBLuminanceSource</code>去处理。在下节介绍的图像识别算法中我们可以知道，大部分二维码的识别都是基于二值化的方法，在色域的处理上，YUV的二值化效果要优于RGB，并且RGB图像在处理中不支持旋转。因此，一种优化的思路是讲所有ARGB编码的图像转换成YUV编码，再使用<code>PlanarYUVLuminanceSource</code>去处理生成的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * RGB转YUV420sp</div><div class="line"> *</div><div class="line"> * @param yuv420sp inputWidth * inputHeight * 3 / 2</div><div class="line"> * @param argb inputWidth * inputHeight</div><div class="line"> * @param width image width</div><div class="line"> * @param height image height</div><div class="line"> */</div><div class="line">private static void encodeYUV420SP(byte[] yuv420sp, int[] argb, int width, int height) &#123;</div><div class="line">    // 帧图片的像素大小</div><div class="line">    final int frameSize = width * height;</div><div class="line">    // ---YUV数据---</div><div class="line">    int Y, U, V;</div><div class="line">    // Y的index从0开始</div><div class="line">    int yIndex = 0;</div><div class="line">    // UV的index从frameSize开始</div><div class="line">    int uvIndex = frameSize;</div><div class="line"></div><div class="line">    // ---颜色数据---</div><div class="line">    int R, G, B;</div><div class="line">    int rgbIndex = 0;</div><div class="line"></div><div class="line">    // ---循环所有像素点，RGB转YUV---</div><div class="line">    for (int j = 0; j &lt; height; j++) &#123;</div><div class="line">        for (int i = 0; i &lt; width; i++) &#123;</div><div class="line"></div><div class="line">            R = (argb[rgbIndex] &amp; 0xff0000) &gt;&gt; 16;</div><div class="line">            G = (argb[rgbIndex] &amp; 0xff00) &gt;&gt; 8;</div><div class="line">            B = (argb[rgbIndex] &amp; 0xff);</div><div class="line">            //</div><div class="line">            rgbIndex++;</div><div class="line"></div><div class="line">            // well known RGB to YUV algorithm</div><div class="line">            Y = ((66 * R + 129 * G + 25 * B + 128) &gt;&gt; 8) + 16;</div><div class="line">            U = ((-38 * R - 74 * G + 112 * B + 128) &gt;&gt; 8) + 128;</div><div class="line">            V = ((112 * R - 94 * G - 18 * B + 128) &gt;&gt; 8) + 128;</div><div class="line"></div><div class="line">            Y = Math.max(0, Math.min(Y, 255));</div><div class="line">            U = Math.max(0, Math.min(U, 255));</div><div class="line">            V = Math.max(0, Math.min(V, 255));</div><div class="line"></div><div class="line">            // NV21 has a plane of Y and interleaved planes of VU each sampled by a factor of 2</div><div class="line">            // meaning for every 4 Y pixels there are 1 V and 1 U. Note the sampling is every other</div><div class="line">            // pixel AND every other scan line.</div><div class="line">            // ---Y---</div><div class="line">            yuv420sp[yIndex++] = (byte) Y;</div><div class="line">            // ---UV---</div><div class="line">            if ((j % 2 == 0) &amp;&amp; (i % 2 == 0)) &#123;</div><div class="line">                //</div><div class="line">                yuv420sp[uvIndex++] = (byte) V;</div><div class="line">                //</div><div class="line">                yuv420sp[uvIndex++] = (byte) U;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Android中读取一张图片一般是通过<code>BitmapFactory.decodeFile(imgPath, options)</code>这个方法去得到这张图片的Bitmap数据，Bitmap是由ARGB值编码得到的，因此如果需要转换成YUV，还需要做一点小小的变换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">private static byte[] yuvs;</div><div class="line">/**</div><div class="line"> * 根据Bitmap的ARGB值生成YUV420SP数据。</div><div class="line"> *</div><div class="line"> * @param inputWidth image width</div><div class="line"> * @param inputHeight image height</div><div class="line"> * @param scaled bmp</div><div class="line"> * @return YUV420SP数组</div><div class="line"> */</div><div class="line">public static byte[] getYUV420sp(int inputWidth, int inputHeight, Bitmap scaled) &#123;</div><div class="line">    int[] argb = new int[inputWidth * inputHeight];</div><div class="line"></div><div class="line">    scaled.getPixels(argb, 0, inputWidth, 0, 0, inputWidth, inputHeight);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 需要转换成偶数的像素点，否则编码YUV420的时候有可能导致分配的空间大小不够而溢出。</div><div class="line">     */</div><div class="line">    int requiredWidth = inputWidth % 2 == 0 ? inputWidth : inputWidth + 1;</div><div class="line">    int requiredHeight = inputHeight % 2 == 0 ? inputHeight : inputHeight + 1;</div><div class="line"></div><div class="line">    int byteLength = requiredWidth * requiredHeight * 3 / 2;</div><div class="line">    if (yuvs == null || yuvs.length &lt; byteLength) &#123;</div><div class="line">        yuvs = new byte[byteLength];</div><div class="line">    &#125; else &#123;</div><div class="line">        Arrays.fill(yuvs, (byte) 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    encodeYUV420SP(yuvs, argb, inputWidth, inputHeight);</div><div class="line"></div><div class="line">    scaled.recycle();</div><div class="line"></div><div class="line">    return yuvs;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面有几个坑，在方法里已经列出来了。首先，如果每次都生成新的YUV数组，不知道在扫一扫解码时要进行GC多少次。。。所以就采用了静态的数组变量来存储数据，只有当当前的长宽乘积超过数组大小时，才重新生成新的<em><code>yuvs</code></em>。其次，如果鉴于YUV的特性，长宽只能是偶数个像素点，否则可能会造成数组溢出(不信可以尝试)。最后，使用完了Bitmap要记得回收，那玩意吃内存不是随便说说的。</p>
<h2 id="二维码图像识别算法选择"><a href="#二维码图像识别算法选择" class="headerlink" title="二维码图像识别算法选择"></a>二维码图像识别算法选择</h2><p>二维码扫描精度和许多因素有关，最关键的因素是扫描算法。目前在图形识别领域中，较常用的二维码识别算法主要有两种，分别是<code>HybridBinarizer</code>和<code>GlobalHistogramBinarizer</code>，这两种算法都是基于二值化，即将图片的色域变为黑白两个颜色，然后提取图形中的二维码矩阵。实际上，zxing中的HybridBinarizer继承自GlobalHistogramBinarizer，并在此基础上做了功能性的改进。援引官方介绍：</p>
<p><strong>This Binarizer(GlobalHistogramBinarizer) implementation uses the old ZXing global histogram approach. It is suitable for low-end mobile devices which don’t have enough CPU or memory to use a local thresholding algorithm. However, because it picks a global black point, it cannot handle difficult shadows and gradients. Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.</strong></p>
<p><strong>This class(HybridBinarizer) implements a local thresholding algorithm, which while slower than the GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for high frequency images of barcodes with black data on white backgrounds. For this application, it does a much better job than a global blackpoint with severe shadows and gradients. However it tends to produce artifacts on lower frequency images and is therefore not a good general purpose binarizer for uses outside ZXing. This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers, and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already inherently local, and only fails for horizontal gradients. We can revisit that problem later, but for now it was not a win to use local blocks for 1D.</strong> ···</p>
<p><code>GlobalHistogramBinarizer</code>算法<strong>适合于低端的设备，对手机的CPU和内存要求不高</strong>。但它选择了全部的黑点来计算，因此无法处理阴影和渐变这两种情况。HybridBinarizer算法在执行效率上要慢于GlobalHistogramBinarizer算法，但识别相对更有效。它专门为<strong>以白色为背景的连续黑色块二维码图像</strong>解析而设计，也更适合用来解析具有<strong>严重阴影和渐变</strong>的二维码图像。</p>
<p>网上对这两种算法的解析并不多，目前仅找到一篇文章详解了GlobalHistogramBinarizer算法，详见<a href="[http://kuangjianwei.blog.163.com/blog/static/190088953201361015055110/]()">[http://kuangjianwei.blog.163.com/blog/static/190088953201361015055110/]()</a>。有时间再看一下相关源码。</p>
<p>zxing项目官方默认使用的是HybridBinarizer二值化方法。在实际的测试中，和官方的介绍大致一样。然而目前的大部分二维码都是黑色二维码，白色背景的。不管是二维码扫描还是二维码图像识别，使用GlobalHistogramBinarizer算法的效果要稍微比HybridBinarizer好一些，识别的速度更快，对低分辨的图像识别精度更高。</p>
<p>除了这两种算法，我相信在图像识别领域肯定还有更好的算法存在，目前受限于知识水平，对二值化算法这一块还比较陌生，期待以后能够深入理解并改进目前的开源算法(*^__^*)……</p>
<h2 id="图像大小对识别精度的影响"><a href="#图像大小对识别精度的影响" class="headerlink" title="图像大小对识别精度的影响"></a>图像大小对识别精度的影响</h2><p>这点是测试中无意发现的。现在的手机摄像头拍照出现的照片像素都很高，动不动就1200W像素，1600W像素，甚至是2000W都不稀奇，但照片的成像质量不一定高。将一张高分辨率的图片按原分辨率导入Android手机，很容易产生OOM。我们来计算一下，导入一张1200W像素的图片需要的内存，假设图片是<code>4000px*3000px</code>，如果导入的图片采用ARGB_8888编码形式，则每个像素需要占用4个Bytes(分别存储ARGB值)来存储，则需要<code>4000*3000*4bytes=45.776MB</code>的内存，这在有限的移动资源里，显然是不能忍受的。</p>
<p>通过上一节对图像算法的简单研究，在<code>GlobalHistogramBinarizer</code>中，是从图像中均匀取5行（覆盖整个图像高度），每行取中间五分之四作为样本；以灰度值为X轴，每个灰度值的像素个数为Y轴建立一个直方图，从直方图中取点数最多的一个灰度值，然后再去给其他的灰度值进行分数计算，按照点数乘以与最多点数灰度值的距离的平方来进行打分，选分数最高的一个灰度值。接下来在这两个灰度值中间选取一个区分界限，取的原则是尽量靠近中间并且要点数越少越好。界限有了以后就容易了，与整幅图像的每个点进行比较，如果灰度值比界限小的就是黑，在新的矩阵中将该点置1，其余的就是白，为0。（摘自<a href="http://kuangjianwei.blog.163.com/blog/static/190088953201361015055110/" target="_blank" rel="external">zxing源码分析——QR码部分</a>）</p>
<p>根据算法的实现，可以知道图像的分辨率对二维码的取值是有影响的。并不是图像的分辨率越高就越容易取到二维码。高分辨率的图像对Android的内存资源占用也很可怕。所以在测试的过程中，我尝试将图片压缩成不同大小分辨率，然后再进行图片的二维码识别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 根据给定的宽度和高度动态计算图片压缩比率</div><div class="line"> * </div><div class="line"> * @param options Bitmap配置文件</div><div class="line"> * @param reqWidth 需要压缩到的宽度</div><div class="line"> * @param reqHeight 需要压缩到的高度</div><div class="line"> * @return 压缩比</div><div class="line"> */</div><div class="line">public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123;</div><div class="line">    // Raw height and width of image</div><div class="line">    final int height = options.outHeight;</div><div class="line">    final int width = options.outWidth;</div><div class="line">    int inSampleSize = 1;</div><div class="line"></div><div class="line">    if (height &gt; reqHeight || width &gt; reqWidth) &#123;</div><div class="line"></div><div class="line">        final int halfHeight = height / 2;</div><div class="line">        final int halfWidth = width / 2;</div><div class="line"></div><div class="line">        // Calculate the largest inSampleSize value that is a power of 2 and keeps both</div><div class="line">        // height and width larger than the requested height and width.</div><div class="line">        while ((halfHeight / inSampleSize) &gt; reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) &#123;</div><div class="line">            inSampleSize *= 2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return inSampleSize;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将图片根据压缩比压缩成固定宽高的Bitmap，实际解析的图片大小可能和#reqWidth、#reqHeight不一样。</div><div class="line"> * </div><div class="line"> * @param imgPath 图片地址</div><div class="line"> * @param reqWidth 需要压缩到的宽度</div><div class="line"> * @param reqHeight 需要压缩到的高度</div><div class="line"> * @return Bitmap</div><div class="line"> */</div><div class="line">public static Bitmap decodeSampledBitmapFromFile(String imgPath, int reqWidth, int reqHeight) &#123;</div><div class="line"></div><div class="line">    // First decode with inJustDecodeBounds=true to check dimensions</div><div class="line">    final BitmapFactory.Options options = new BitmapFactory.Options();</div><div class="line">    options.inJustDecodeBounds = true;</div><div class="line">    BitmapFactory.decodeFile(imgPath, options);</div><div class="line"></div><div class="line">    // Calculate inSampleSize</div><div class="line">    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</div><div class="line"></div><div class="line">    // Decode bitmap with inSampleSize set</div><div class="line">    options.inJustDecodeBounds = false;</div><div class="line">    return BitmapFactory.decodeFile(imgPath, options);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Android图片优化需要通过在解析图片的时候，设置<code>BitmapFactory.Options.inSampleSize</code>的值，根据比例压缩图片大小。在进行图片二维码解析的线程中，通过设置不同的图片大小，来测试二维码的识别率。这个测试过程我忘记保存了，只记得测试了压缩成最大宽高值为2048、1024、512、256和128像素的包含二维码的图片，但实际的测试结果是，当<code>MAX_PICTURE_PIXEL=256</code>的时候识别率最高。</p>
<p><strong>此结论不具备理论支持，有兴趣的童鞋可以自己动手尝试。^_^</strong></p>
<h2 id="相机预览倍数设置及聚焦时间调整"><a href="#相机预览倍数设置及聚焦时间调整" class="headerlink" title="相机预览倍数设置及聚焦时间调整"></a>相机预览倍数设置及聚焦时间调整</h2><p>如果使用zxing默认的相机配置，会发现需要离二维码很近才能够识别出来，但这样会带来一个问题——聚焦困难。解决办法就是调整相机预览倍数以及减小相机聚焦的时间。</p>
<p>通过测试可以发现，每个手机的最大放大倍数几乎是不一样的，这可能和摄像头的型号有关。如果设置成一个固定的值，那可能会产生在某些手机上过度放大，某些手机上放大的倍数不够。索性相机的参数设定里给我们提供了最大的放大倍数值，通过取放大倍数值的N分之一作为当前的放大倍数，就完美地解决了手机的适配问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 需要判断摄像头是否支持缩放</div><div class="line">Parameters parameters = camera.getParameters();</div><div class="line">if (parameters.isZoomSupported()) &#123;</div><div class="line">	// 设置成最大倍数的1/10，基本符合远近需求</div><div class="line">    parameters.setZoom(parameters.getMaxZoom() / 10);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>zxing默认的相机聚焦时间是<code>2s</code>，可以根据扫描的视觉适当调整。聚焦时间的调整也很简单，在<code>AutoFocusCallback</code>这个类里，调整<code>AUTO_FOCUS_INTERVAL_MS</code>这个值就可以了。</p>
<h1 id="二维码扫描视觉调整"><a href="#二维码扫描视觉调整" class="headerlink" title="二维码扫描视觉调整"></a>二维码扫描视觉调整</h1><p>二维码扫描视觉的绘制在<code>ViewfinderView.java</code>完成，官方是继承了View然后在<code>onDraw()</code>方法中实现了视图的绘制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onDraw(Canvas canvas) &#123;</div><div class="line">    if (cameraManager == null) &#123;</div><div class="line">        return; // not ready yet, early draw before done configuring</div><div class="line">    &#125;</div><div class="line">    Rect frame = cameraManager.getFramingRect();</div><div class="line">    Rect previewFrame = cameraManager.getFramingRectInPreview();</div><div class="line">    if (frame == null || previewFrame == null) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int width = canvas.getWidth();</div><div class="line">    int height = canvas.getHeight();</div><div class="line"></div><div class="line">    // 绘制聚焦框外的暗色透明层</div><div class="line">    paint.setColor(resultBitmap != null ? resultColor : maskColor);</div><div class="line">    canvas.drawRect(0, 0, width, frame.top, paint);</div><div class="line">    canvas.drawRect(0, frame.top, frame.left, frame.bottom + 1, paint);</div><div class="line">    canvas.drawRect(frame.right + 1, frame.top, width, frame.bottom + 1, paint);</div><div class="line">    canvas.drawRect(0, frame.bottom + 1, width, height, paint);</div><div class="line"></div><div class="line">    if (resultBitmap != null) &#123;</div><div class="line">        // 如果扫描结果不为空，则把扫描的结果填充到聚焦框中</div><div class="line">        paint.setAlpha(CURRENT_POINT_OPACITY);</div><div class="line">        canvas.drawBitmap(resultBitmap, null, frame, paint);</div><div class="line">    &#125; else &#123;</div><div class="line"></div><div class="line">        // 画一根红色的激光线表示二维码解码正在进行</div><div class="line">        paint.setColor(laserColor);</div><div class="line">        paint.setAlpha(SCANNER_ALPHA[scannerAlpha]);</div><div class="line">        scannerAlpha = (scannerAlpha + 1) % SCANNER_ALPHA.length;</div><div class="line">        int middle = frame.height() / 2 + frame.top;</div><div class="line">        canvas.drawRect(frame.left + 2, middle - 1, frame.right - 1, middle + 2, paint);</div><div class="line"></div><div class="line">        float scaleX = frame.width() / (float) previewFrame.width();</div><div class="line">        float scaleY = frame.height() / (float) previewFrame.height();</div><div class="line"></div><div class="line">        List&lt;ResultPoint&gt; currentPossible = possibleResultPoints;</div><div class="line">        List&lt;ResultPoint&gt; currentLast = lastPossibleResultPoints;</div><div class="line">        int frameLeft = frame.left;</div><div class="line">        int frameTop = frame.top;</div><div class="line"></div><div class="line">        // 绘制解析过程中可能扫描到的关键点，使用黄色小圆点表示</div><div class="line">        if (currentPossible.isEmpty()) &#123;</div><div class="line">            lastPossibleResultPoints = null;</div><div class="line">        &#125; else &#123;</div><div class="line">            possibleResultPoints = new ArrayList&lt;&gt;(5);</div><div class="line">            lastPossibleResultPoints = currentPossible;</div><div class="line">            paint.setAlpha(CURRENT_POINT_OPACITY);</div><div class="line">            paint.setColor(resultPointColor);</div><div class="line">            synchronized (currentPossible) &#123;</div><div class="line">                for (ResultPoint point : currentPossible) &#123;</div><div class="line">                    canvas.drawCircle(frameLeft + (int) (point.getX() * scaleX),</div><div class="line">                        frameTop + (int) (point.getY() * scaleY), POINT_SIZE, paint);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (currentLast != null) &#123;</div><div class="line">            paint.setAlpha(CURRENT_POINT_OPACITY / 2);</div><div class="line">            paint.setColor(resultPointColor);</div><div class="line">            synchronized (currentLast) &#123;</div><div class="line">                float radius = POINT_SIZE / 2.0f;</div><div class="line">                for (ResultPoint point : currentLast) &#123;</div><div class="line">                    canvas.drawCircle(frameLeft + (int) (point.getX() * scaleX),</div><div class="line">                        frameTop + (int) (point.getY() * scaleY), radius, paint);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 重绘聚焦框里的内容，不需要重绘整个界面。</div><div class="line">        postInvalidateDelayed(ANIMATION_DELAY, frame.left - POINT_SIZE, frame.top - POINT_SIZE,</div><div class="line">            frame.right + POINT_SIZE, frame.bottom + POINT_SIZE);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我给它做了一点小改变，效果差不多，代码更简洁一些。由于代码中我不是根据屏幕的宽高动态计算聚焦框的大小，因此这里省去了从CameraManager获取FramingRect和FramingRectInPreview这两个矩形的过程。我在聚焦框外加了四个角，目前大部分二维码产品基本都是这么设计的吧，当然也可以使用图片来代替。总之视觉定制是因人而异，这里不做过多介绍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onDraw(Canvas canvas) &#123;</div><div class="line">    if (isInEditMode()) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    Rect frame = mFrameRect;</div><div class="line">    if (frame == null) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int width = canvas.getWidth();</div><div class="line">    int height = canvas.getHeight();</div><div class="line"></div><div class="line">    // 绘制焦点框外边的暗色背景</div><div class="line">    mPaint.setColor(mMaskColor);</div><div class="line">    canvas.drawRect(0, 0, width, frame.top, mPaint);</div><div class="line">    canvas.drawRect(0, frame.top, frame.left, frame.bottom + 1, mPaint);</div><div class="line">    canvas.drawRect(frame.right + 1, frame.top, width, frame.bottom + 1, mPaint);</div><div class="line">    canvas.drawRect(0, frame.bottom + 1, width, height, mPaint);</div><div class="line"></div><div class="line">    drawFocusRect(canvas, frame);</div><div class="line">    drawAngle(canvas, frame);</div><div class="line">    drawText(canvas, frame);</div><div class="line">    drawLaser(canvas, frame);</div><div class="line"></div><div class="line">    // Request another update at the animation interval, but only repaint the laser line,</div><div class="line">    // not the entire viewfinder mask.</div><div class="line">    postInvalidateDelayed(ANIMATION_DELAY, frame.left, frame.top, frame.right, frame.bottom);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 画聚焦框，白色的</div><div class="line"> * </div><div class="line"> * @param canvas</div><div class="line"> * @param rect</div><div class="line"> */</div><div class="line">private void drawFocusRect(Canvas canvas, Rect rect) &#123;</div><div class="line">    // 绘制焦点框（黑色）</div><div class="line">    mPaint.setColor(mFrameColor);</div><div class="line">    // 上</div><div class="line">    canvas.drawRect(rect.left + mAngleLength, rect.top, rect.right - mAngleLength, rect.top + mFocusThick, mPaint);</div><div class="line">    // 左</div><div class="line">    canvas.drawRect(rect.left, rect.top + mAngleLength, rect.left + mFocusThick, rect.bottom - mAngleLength,</div><div class="line">        mPaint);</div><div class="line">    // 右</div><div class="line">    canvas.drawRect(rect.right - mFocusThick, rect.top + mAngleLength, rect.right, rect.bottom - mAngleLength,</div><div class="line">        mPaint);</div><div class="line">    // 下</div><div class="line">    canvas.drawRect(rect.left + mAngleLength, rect.bottom - mFocusThick, rect.right - mAngleLength, rect.bottom,</div><div class="line">        mPaint);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 画粉色的四个角</div><div class="line"> * </div><div class="line"> * @param canvas</div><div class="line"> * @param rect</div><div class="line"> */</div><div class="line">private void drawAngle(Canvas canvas, Rect rect) &#123;</div><div class="line">    mPaint.setColor(mLaserColor);</div><div class="line">    mPaint.setAlpha(OPAQUE);</div><div class="line">    mPaint.setStyle(Paint.Style.FILL);</div><div class="line">    mPaint.setStrokeWidth(mAngleThick);</div><div class="line">    int left = rect.left;</div><div class="line">    int top = rect.top;</div><div class="line">    int right = rect.right;</div><div class="line">    int bottom = rect.bottom;</div><div class="line">    // 左上角</div><div class="line">    canvas.drawRect(left, top, left + mAngleLength, top + mAngleThick, mPaint);</div><div class="line">    canvas.drawRect(left, top, left + mAngleThick, top + mAngleLength, mPaint);</div><div class="line">    // 右上角</div><div class="line">    canvas.drawRect(right - mAngleLength, top, right, top + mAngleThick, mPaint);</div><div class="line">    canvas.drawRect(right - mAngleThick, top, right, top + mAngleLength, mPaint);</div><div class="line">    // 左下角</div><div class="line">    canvas.drawRect(left, bottom - mAngleLength, left + mAngleThick, bottom, mPaint);</div><div class="line">    canvas.drawRect(left, bottom - mAngleThick, left + mAngleLength, bottom, mPaint);</div><div class="line">    // 右下角</div><div class="line">    canvas.drawRect(right - mAngleLength, bottom - mAngleThick, right, bottom, mPaint);</div><div class="line">    canvas.drawRect(right - mAngleThick, bottom - mAngleLength, right, bottom, mPaint);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void drawText(Canvas canvas, Rect rect) &#123;</div><div class="line">    int margin = 40;</div><div class="line">    mPaint.setColor(mTextColor);</div><div class="line">    mPaint.setTextSize(getResources().getDimension(R.dimen.text_size_13sp));</div><div class="line">    String text = getResources().getString(R.string.qr_code_auto_scan_notification);</div><div class="line">    Paint.FontMetrics fontMetrics = mPaint.getFontMetrics();</div><div class="line">    float fontTotalHeight = fontMetrics.bottom - fontMetrics.top;</div><div class="line">    float offY = fontTotalHeight / 2 - fontMetrics.bottom;</div><div class="line">    float newY = rect.bottom + margin + offY;</div><div class="line">    float left = (ScreenUtils.getScreenWidth(mContext) - mPaint.getTextSize() * text.length()) / 2;</div><div class="line">    canvas.drawText(text, left, newY, mPaint);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void drawLaser(Canvas canvas, Rect rect) &#123;</div><div class="line">    // 绘制焦点框内固定的一条扫描线（红色）</div><div class="line">    mPaint.setColor(mLaserColor);</div><div class="line">    mPaint.setAlpha(SCANNER_ALPHA[mScannerAlpha]);</div><div class="line">    mScannerAlpha = (mScannerAlpha + 1) % SCANNER_ALPHA.length;</div><div class="line">    int middle = rect.height() / 2 + rect.top;</div><div class="line">    canvas.drawRect(rect.left + 2, middle - 1, rect.right - 1, middle + 2, mPaint);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用zxing进行二维码的编解码是非常方便的，zxing的API覆盖了多种主流编程语言，具有良好的扩展性和可定制性。文中进行了二维码基本功能介绍，zxing项目基本使用方法，zxing项目中目前存在的缺点及改进方案，以及自己在进行zxing项目二次开发的摸索过程中总结出的提高二维码扫描的方法。文中还有许多不足的地方，对源码的理解还不够深，特别是二维码解析关键算法（<code>GlobalHistogramBinarizer</code>和<code>HybridBinarizer</code>）。这些算法需要投入额外的时间去理解，对于目前以业务为导向的App开发来说，还存在优化的空间，期待将来有一天能像微信的二维码扫描一样快速，精确。</p>
<p>项目源码：<a href="https://github.com/iluhcm/QrCodeScanner" target="_blank" rel="external">https://github.com/iluhcm/QrCodeScanner</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>Post author:</strong>
      Xing Li
    </li>
    <li class="post-copyright-link">
      <strong>Post link:</strong>
      <a href="http://iluhcm.com/2016/01/08/scan-qr-code-and-recognize-it-from-picture-fastly-using-zxing/" title="zxing扫描二维码和识别图片二维码及其优化策略">http://iluhcm.com/2016/01/08/scan-qr-code-and-recognize-it-from-picture-fastly-using-zxing/</a>
    </li>
    <li class="post-copyright-license">
      <strong>Copyright Notice: </strong>
      All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.
    </li>
  </ul>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/zxing/" rel="tag"># zxing</a>
          
            <a href="/tags/QR-Code/" rel="tag"># QR Code</a>
          
            <a href="/tags/Optimization-Strategy/" rel="tag"># Optimization Strategy</a>
          
            <a href="/tags/Camera/" rel="tag"># Camera</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/12/29/access-github-using-ssh-over-the-HTTPS-port/" rel="next" title="通过SSH-over-HTTPS访问Github">
                <i class="fa fa-chevron-left"></i> 通过SSH-over-HTTPS访问Github
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/02/23/a-vim-tutorial-and-primer-by-translation/" rel="prev" title="【译】VIM初级与进阶教程">
                【译】VIM初级与进阶教程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div id="sidebar-dimmer"></div>
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Xing Li" />
          <p class="site-author-name" itemprop="name">Xing Li</p>
           
              <p class="site-description motion-element" itemprop="description">If asked how the pond can be so lucid and fresh, told that sources with flowing water replenish.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">51</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/iluhcm" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/xing.li.731135" target="_blank" title="Facebook">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                  Facebook
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/iluhcm" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://plus.google.com/101164893136136383839/posts" target="_blank" title="Google+">
                  
                    <i class="fa fa-fw fa-google-plus"></i>
                  
                  Google+
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/lshcm" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/iluhcm" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Zhihu
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://music.163.com/#/user/home?id=38148117" target="_blank" title="Netease">
                  
                    <i class="fa fa-fw fa-music"></i>
                  
                  Netease
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#二维码介绍"><span class="nav-number">1.</span> <span class="nav-text">二维码介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zxing基本使用"><span class="nav-number">2.</span> <span class="nav-text">zxing基本使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zxing源码存在的问题及解决方案"><span class="nav-number">3.</span> <span class="nav-text">zxing源码存在的问题及解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#图形拉伸问题"><span class="nav-number">3.1.</span> <span class="nav-text">图形拉伸问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扫描精度问题"><span class="nav-number">3.2.</span> <span class="nav-text">扫描精度问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PlanarYUVLuminanceSource"><span class="nav-number">3.2.1.</span> <span class="nav-text">PlanarYUVLuminanceSource</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DecodeHintType"><span class="nav-number">3.2.2.</span> <span class="nav-text">DecodeHintType</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二维码图像识别精度探究"><span class="nav-number">4.</span> <span class="nav-text">二维码图像识别精度探究</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#图像-像素编码格式"><span class="nav-number">4.1.</span> <span class="nav-text">图像/像素编码格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二维码图像识别算法选择"><span class="nav-number">4.2.</span> <span class="nav-text">二维码图像识别算法选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图像大小对识别精度的影响"><span class="nav-number">4.3.</span> <span class="nav-text">图像大小对识别精度的影响</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相机预览倍数设置及聚焦时间调整"><span class="nav-number">4.4.</span> <span class="nav-text">相机预览倍数设置及聚焦时间调整</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二维码扫描视觉调整"><span class="nav-number">5.</span> <span class="nav-text">二维码扫描视觉调整</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xing Li</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("CI5TJwN9TiLhei285z2E32es-gzGzoHsz", "RwQ5NncufhCOGqfbhKM1ucxz");AV.useAVCloudUS();</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
